### 定义：

在 GoF 的《设计模式》一书中，组合模式是这样定义的：
Compose objects into tree structure to represent part-whole hierarchies.
Composite lets client treat individual objects and compositions of objects uniformly.
将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。
组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。

数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。
但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。

组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。
其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。

组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。
使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。
所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。

### 示例：

- 动态地添加、删除某个目录下的子目录或文件。
- 统计指定目录下的文件个数。
- 统计指定目录下的文件总大小。

1、不使用组合模式。
2、文件和目录从业务上是两个概念
单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。
但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，
我们最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。

### 总结：

#### 优点：

代码可读性、维护性、扩展性 强

#### 缺点：

因为是递归，所以有重复计算的可能，故性能不高。
在文件系统那个例子中，countNumOfFiles() 和 countSizeOfFiles() 这两个函数实现的效率并不高，因为每次调用它们的时候，都要重新遍历一遍子树。

#### 优化：

实质是"递归代码要警惕重复计算"问题！可以用散列表存储每个(path,size)，通过路径直接返回对应的size,删除或者添加的时候，维护这个size即可。

争哥《数据结构与算法之美》第十讲：为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。